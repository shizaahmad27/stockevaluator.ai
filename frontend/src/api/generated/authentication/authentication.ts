/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/vue-query";
import type {
  DataTag,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryReturnType,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from "@tanstack/vue-query";

import { unref } from "vue";
import type { MaybeRef } from "vue";

import type {
  CompletePasswordResetRequest,
  LoginRequest,
  LoginResponse,
  PasswordResetResponse,
  RefreshRequest,
  RefreshResponse,
  RegisterRequest,
  RegisterResponse,
  UserResponse,
  VerifyEmailParams,
} from ".././model";

import { customInstanceFn } from "../../mutator/custom-instance";

/**
 * Verifies user's email address using a token
 * @summary Verify email address
 */
export const verifyEmail = (
  params: MaybeRef<VerifyEmailParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return customInstanceFn<string>({
    url: `/api/auth/verify-email`,
    method: "POST",
    params: unref(params),
    signal,
  });
};

export const getVerifyEmailMutationOptions = <
  TError = string,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof verifyEmail>>,
    TError,
    { params: VerifyEmailParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof verifyEmail>>,
  TError,
  { params: VerifyEmailParams },
  TContext
> => {
  const mutationKey = ["verifyEmail"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof verifyEmail>>,
    { params: VerifyEmailParams }
  > = (props) => {
    const { params } = props ?? {};

    return verifyEmail(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type VerifyEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof verifyEmail>>
>;

export type VerifyEmailMutationError = string;

/**
 * @summary Verify email address
 */
export const useVerifyEmail = <TError = string, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof verifyEmail>>,
      TError,
      { params: VerifyEmailParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof verifyEmail>>,
  TError,
  { params: VerifyEmailParams },
  TContext
> => {
  const mutationOptions = getVerifyEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a new user account after CAPTCHA verification and input validation
 * @summary Register a new user
 */
export const register = (
  registerRequest: MaybeRef<RegisterRequest>,
  signal?: AbortSignal,
) => {
  registerRequest = unref(registerRequest);

  return customInstanceFn<RegisterResponse>({
    url: `/api/auth/register`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: registerRequest,
    signal,
  });
};

export const getRegisterMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: RegisterRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterRequest },
  TContext
> => {
  const mutationKey = ["register"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof register>>,
    { data: RegisterRequest }
  > = (props) => {
    const { data } = props ?? {};

    return register(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof register>>
>;
export type RegisterMutationBody = RegisterRequest;
export type RegisterMutationError = unknown;

/**
 * @summary Register a new user
 */
export const useRegister = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof register>>,
      TError,
      { data: RegisterRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterRequest },
  TContext
> => {
  const mutationOptions = getRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Generates new access token using refresh token
 * @summary Refresh token
 */
export const refresh = (
  refreshRequest: MaybeRef<RefreshRequest>,
  signal?: AbortSignal,
) => {
  refreshRequest = unref(refreshRequest);

  return customInstanceFn<RefreshResponse>({
    url: `/api/auth/refresh`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: refreshRequest,
    signal,
  });
};

export const getRefreshMutationOptions = <
  TError = RefreshResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refresh>>,
    TError,
    { data: RefreshRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refresh>>,
  TError,
  { data: RefreshRequest },
  TContext
> => {
  const mutationKey = ["refresh"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refresh>>,
    { data: RefreshRequest }
  > = (props) => {
    const { data } = props ?? {};

    return refresh(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof refresh>>
>;
export type RefreshMutationBody = RefreshRequest;
export type RefreshMutationError = RefreshResponse;

/**
 * @summary Refresh token
 */
export const useRefresh = <TError = RefreshResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refresh>>,
      TError,
      { data: RefreshRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof refresh>>,
  TError,
  { data: RefreshRequest },
  TContext
> => {
  const mutationOptions = getRefreshMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Authenticates a user and returns access tokens
 * @summary Login user
 */
export const login = (
  loginRequest: MaybeRef<LoginRequest>,
  signal?: AbortSignal,
) => {
  loginRequest = unref(loginRequest);

  return customInstanceFn<LoginResponse>({
    url: `/api/auth/login`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: loginRequest,
    signal,
  });
};

export const getLoginMutationOptions = <
  TError = LoginResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginRequest },
  TContext
> => {
  const mutationKey = ["login"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof login>>,
    { data: LoginRequest }
  > = (props) => {
    const { data } = props ?? {};

    return login(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof login>>
>;
export type LoginMutationBody = LoginRequest;
export type LoginMutationError = LoginResponse;

/**
 * @summary Login user
 */
export const useLogin = <TError = LoginResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof login>>,
      TError,
      { data: LoginRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginRequest },
  TContext
> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Verifies the reset token and updates the user's password
 * @summary Complete password reset
 */
export const completePasswordReset = (
  completePasswordResetRequest: MaybeRef<CompletePasswordResetRequest>,
  signal?: AbortSignal,
) => {
  completePasswordResetRequest = unref(completePasswordResetRequest);

  return customInstanceFn<PasswordResetResponse>({
    url: `/api/auth/complete-password-reset`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: completePasswordResetRequest,
    signal,
  });
};

export const getCompletePasswordResetMutationOptions = <
  TError = PasswordResetResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completePasswordReset>>,
    TError,
    { data: CompletePasswordResetRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof completePasswordReset>>,
  TError,
  { data: CompletePasswordResetRequest },
  TContext
> => {
  const mutationKey = ["completePasswordReset"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof completePasswordReset>>,
    { data: CompletePasswordResetRequest }
  > = (props) => {
    const { data } = props ?? {};

    return completePasswordReset(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CompletePasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof completePasswordReset>>
>;
export type CompletePasswordResetMutationBody = CompletePasswordResetRequest;
export type CompletePasswordResetMutationError = PasswordResetResponse;

/**
 * @summary Complete password reset
 */
export const useCompletePasswordReset = <
  TError = PasswordResetResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof completePasswordReset>>,
      TError,
      { data: CompletePasswordResetRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof completePasswordReset>>,
  TError,
  { data: CompletePasswordResetRequest },
  TContext
> => {
  const mutationOptions = getCompletePasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieves the currently authenticated user's details
 * @summary Get current user
 */
export const me = (signal?: AbortSignal) => {
  return customInstanceFn<UserResponse>({
    url: `/api/auth/me`,
    method: "GET",
    signal,
  });
};

export const getMeQueryKey = () => {
  return ["api", "auth", "me"] as const;
};

export const getMeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof me>>>,
  TError = UserResponse,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) =>
    me(signal);

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>;
};

export type MeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>;
export type MeInfiniteQueryError = UserResponse;

/**
 * @summary Get current user
 */

export function useMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof me>>>,
  TError = UserResponse,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMeInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

export const getMeQueryOptions = <
  TData = Awaited<ReturnType<typeof me>>,
  TError = UserResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) =>
    me(signal);

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>;
};

export type MeQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>;
export type MeQueryError = UserResponse;

/**
 * @summary Get current user
 */

export function useMe<
  TData = Awaited<ReturnType<typeof me>>,
  TError = UserResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}
